# 算法记录

## Math

**7. 整数反转**

通过对 10 求余和除以 10，获取最后一位数字，累加到结果中。累加前需要判断溢出

**9. 回文数**

反转一半数字，判断是否与另一半相等（注意位数的奇偶），该方法可以防止溢出

**11. 盛最多水的容器**

双指针，贪心算法。从左右向中间收缩，每次收缩较低的一边。原因是收缩时间距在变小，如果不改变较低的一边，那收缩后面积一定会更小

**12. 整数转罗马数字**

模拟，预先从大到小列出所有罗马数字组合，从大到小逐步减

**13. 罗马数字转整数**

模拟，从左到右依次转为数字，需要处理左边数字比右边数字小的情况

**15. 三数之和**

排序+双指针，选定第一个数，其他两数通过双指针从左右两侧遍历。利用排序进行剪枝优化

**16. 最接近的三数之和**
解法同三数之和，排序+双指针。根据三数和与 target 之间的最小差选择结果

**18. 四数之和**
解法类似三数之和，排序+双指针，选定第一个数和第二个数，双指针遍历其他两数

**26. 删除有序数组中的重复项**
快慢指针，快指针找到不重复的数，赋值给慢指针

**27. 移除元素**
(1) 快慢指针，快指针找到不为 val 的数，赋值给慢指针
(2) 快慢指针优化，快指针从右向左，赋值给慢指针为 val 的位置

**29. 两数相除**
用减法模拟乘法，不断循环 1) 减除数，2) 除数翻倍，直到被除数小于需要减去的数，再重新从除数开始减

**31. 下一个排列**
等价于找到下一比当前数字大的数，即把后面的大数与前面的小数交换，且保证交换后的结果最小。需要从右向左，找到第一个比后面数字小的数字 x，把 x 与后面比它大的最小数字交换。交换后，后续序列一定为倒序排列，需要反转为正序

**41. 缺失的第一个正数**
原地哈希，首先交换整数 x 到数组中 x-1 位置，随后遍历找到第一个位置不符合的数
